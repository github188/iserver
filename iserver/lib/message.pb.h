// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_message_2eproto__INCLUDED
#define PROTOBUF_message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace Chat {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_message_2eproto();
void protobuf_AssignDesc_message_2eproto();
void protobuf_ShutdownFile_message_2eproto();

class Region;
class User;
class LoginInfo;
class LoginResult;
class UserConfig;
class PostMsg;
class NetMsgReq;
class NetMsgRsp;
class TransMsg;
class PRIVATE_MSG_RSP;

enum CMD {
  LOGIN_REQUEST = 10001,
  LOGIN_RESPONSE = 10002,
  LOGOUT_REQUEST = 10003,
  CLIENT_HEART_BEAT = 10004,
  CLIENT_GET_CONFIG = 20001,
  CLIENT_GET_CONFIG_RSP = 20002,
  CLIENT_SET_CONFIG = 20003,
  CLIENT_SET_CONFIG_RSP = 20004,
  CLIENT_GET_REGION = 30001,
  CLIENT_GET_REGION_RSP = 30002,
  CLIENT_GET_USER = 30003,
  CLIENT_GET_USER_RSP = 30004,
  CLIENT_POST_MSG = 40001,
  CLIENT_POST_MSG_RSP = 40002,
  CLIENT_RES_RSP = 40003,
  CLIENT_CHAT_INVITE = 50001,
  CLIENT_CHAT_CANCEL = 50002,
  CLIENT_CHAT_ACCEPT = 50003,
  CLIENT_CHAT_REFUSE = 50004,
  CLIENT_CHAT_ERROR = 50005
};
bool CMD_IsValid(int value);
const CMD CMD_MIN = LOGIN_REQUEST;
const CMD CMD_MAX = CLIENT_CHAT_ERROR;
const int CMD_ARRAYSIZE = CMD_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMD_descriptor();
inline const ::std::string& CMD_Name(CMD value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMD_descriptor(), value);
}
inline bool CMD_Parse(
    const ::std::string& name, CMD* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMD>(
    CMD_descriptor(), name, value);
}
// ===================================================================

class Region : public ::google::protobuf::Message {
 public:
  Region();
  virtual ~Region();
  
  Region(const Region& from);
  
  inline Region& operator=(const Region& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Region& default_instance();
  
  void Swap(Region* other);
  
  // implements Message ----------------------------------------------
  
  Region* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Region& from);
  void MergeFrom(const Region& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional int32 parent_id = 4;
  inline bool has_parent_id() const;
  inline void clear_parent_id();
  static const int kParentIdFieldNumber = 4;
  inline ::google::protobuf::int32 parent_id() const;
  inline void set_parent_id(::google::protobuf::int32 value);
  
  // optional int32 ui_handle = 5;
  inline bool has_ui_handle() const;
  inline void clear_ui_handle();
  static const int kUiHandleFieldNumber = 5;
  inline ::google::protobuf::int32 ui_handle() const;
  inline void set_ui_handle(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:Chat.Region)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 id_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::int32 parent_id_;
  ::google::protobuf::int32 ui_handle_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Region* default_instance_;
};
// -------------------------------------------------------------------

class User : public ::google::protobuf::Message {
 public:
  User();
  virtual ~User();
  
  User(const User& from);
  
  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const User& default_instance();
  
  void Swap(User* other);
  
  // implements Message ----------------------------------------------
  
  User* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  
  // optional string user_pwd = 2;
  inline bool has_user_pwd() const;
  inline void clear_user_pwd();
  static const int kUserPwdFieldNumber = 2;
  inline const ::std::string& user_pwd() const;
  inline void set_user_pwd(const ::std::string& value);
  inline void set_user_pwd(const char* value);
  inline void set_user_pwd(const char* value, size_t size);
  inline ::std::string* mutable_user_pwd();
  
  // optional string user_ip = 3;
  inline bool has_user_ip() const;
  inline void clear_user_ip();
  static const int kUserIpFieldNumber = 3;
  inline const ::std::string& user_ip() const;
  inline void set_user_ip(const ::std::string& value);
  inline void set_user_ip(const char* value);
  inline void set_user_ip(const char* value, size_t size);
  inline ::std::string* mutable_user_ip();
  
  // optional string display_name = 4;
  inline bool has_display_name() const;
  inline void clear_display_name();
  static const int kDisplayNameFieldNumber = 4;
  inline const ::std::string& display_name() const;
  inline void set_display_name(const ::std::string& value);
  inline void set_display_name(const char* value);
  inline void set_display_name(const char* value, size_t size);
  inline ::std::string* mutable_display_name();
  
  // optional string user_phone = 5;
  inline bool has_user_phone() const;
  inline void clear_user_phone();
  static const int kUserPhoneFieldNumber = 5;
  inline const ::std::string& user_phone() const;
  inline void set_user_phone(const ::std::string& value);
  inline void set_user_phone(const char* value);
  inline void set_user_phone(const char* value, size_t size);
  inline ::std::string* mutable_user_phone();
  
  // optional int64 longin_time = 6;
  inline bool has_longin_time() const;
  inline void clear_longin_time();
  static const int kLonginTimeFieldNumber = 6;
  inline ::google::protobuf::int64 longin_time() const;
  inline void set_longin_time(::google::protobuf::int64 value);
  
  // optional int64 logout_time = 7;
  inline bool has_logout_time() const;
  inline void clear_logout_time();
  static const int kLogoutTimeFieldNumber = 7;
  inline ::google::protobuf::int64 logout_time() const;
  inline void set_logout_time(::google::protobuf::int64 value);
  
  // optional int64 last_beat = 8;
  inline bool has_last_beat() const;
  inline void clear_last_beat();
  static const int kLastBeatFieldNumber = 8;
  inline ::google::protobuf::int64 last_beat() const;
  inline void set_last_beat(::google::protobuf::int64 value);
  
  // optional int32 parent_id = 9;
  inline bool has_parent_id() const;
  inline void clear_parent_id();
  static const int kParentIdFieldNumber = 9;
  inline ::google::protobuf::int32 parent_id() const;
  inline void set_parent_id(::google::protobuf::int32 value);
  
  // optional int32 user_id = 10;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 10;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);
  
  // optional int32 ui_handle = 11;
  inline bool has_ui_handle() const;
  inline void clear_ui_handle();
  static const int kUiHandleFieldNumber = 11;
  inline ::google::protobuf::int32 ui_handle() const;
  inline void set_ui_handle(::google::protobuf::int32 value);
  
  // optional .Chat.UserConfig user_config = 12;
  inline bool has_user_config() const;
  inline void clear_user_config();
  static const int kUserConfigFieldNumber = 12;
  inline const ::Chat::UserConfig& user_config() const;
  inline ::Chat::UserConfig* mutable_user_config();
  
  // optional int32 udp_port = 13;
  inline bool has_udp_port() const;
  inline void clear_udp_port();
  static const int kUdpPortFieldNumber = 13;
  inline ::google::protobuf::int32 udp_port() const;
  inline void set_udp_port(::google::protobuf::int32 value);
  
  // optional int32 tcp_port = 14;
  inline bool has_tcp_port() const;
  inline void clear_tcp_port();
  static const int kTcpPortFieldNumber = 14;
  inline ::google::protobuf::int32 tcp_port() const;
  inline void set_tcp_port(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:Chat.User)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* user_name_;
  static const ::std::string _default_user_name_;
  ::std::string* user_pwd_;
  static const ::std::string _default_user_pwd_;
  ::std::string* user_ip_;
  static const ::std::string _default_user_ip_;
  ::std::string* display_name_;
  static const ::std::string _default_display_name_;
  ::std::string* user_phone_;
  static const ::std::string _default_user_phone_;
  ::google::protobuf::int64 longin_time_;
  ::google::protobuf::int64 logout_time_;
  ::google::protobuf::int64 last_beat_;
  ::google::protobuf::int32 parent_id_;
  ::google::protobuf::int32 user_id_;
  ::google::protobuf::int32 ui_handle_;
  ::Chat::UserConfig* user_config_;
  ::google::protobuf::int32 udp_port_;
  ::google::protobuf::int32 tcp_port_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static User* default_instance_;
};
// -------------------------------------------------------------------

class LoginInfo : public ::google::protobuf::Message {
 public:
  LoginInfo();
  virtual ~LoginInfo();
  
  LoginInfo(const LoginInfo& from);
  
  inline LoginInfo& operator=(const LoginInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginInfo& default_instance();
  
  void Swap(LoginInfo* other);
  
  // implements Message ----------------------------------------------
  
  LoginInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginInfo& from);
  void MergeFrom(const LoginInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  
  // optional string user_pwd = 2;
  inline bool has_user_pwd() const;
  inline void clear_user_pwd();
  static const int kUserPwdFieldNumber = 2;
  inline const ::std::string& user_pwd() const;
  inline void set_user_pwd(const ::std::string& value);
  inline void set_user_pwd(const char* value);
  inline void set_user_pwd(const char* value, size_t size);
  inline ::std::string* mutable_user_pwd();
  
  // optional string user_ip = 3;
  inline bool has_user_ip() const;
  inline void clear_user_ip();
  static const int kUserIpFieldNumber = 3;
  inline const ::std::string& user_ip() const;
  inline void set_user_ip(const ::std::string& value);
  inline void set_user_ip(const char* value);
  inline void set_user_ip(const char* value, size_t size);
  inline ::std::string* mutable_user_ip();
  
  // @@protoc_insertion_point(class_scope:Chat.LoginInfo)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* user_name_;
  static const ::std::string _default_user_name_;
  ::std::string* user_pwd_;
  static const ::std::string _default_user_pwd_;
  ::std::string* user_ip_;
  static const ::std::string _default_user_ip_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static LoginInfo* default_instance_;
};
// -------------------------------------------------------------------

class LoginResult : public ::google::protobuf::Message {
 public:
  LoginResult();
  virtual ~LoginResult();
  
  LoginResult(const LoginResult& from);
  
  inline LoginResult& operator=(const LoginResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResult& default_instance();
  
  void Swap(LoginResult* other);
  
  // implements Message ----------------------------------------------
  
  LoginResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResult& from);
  void MergeFrom(const LoginResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);
  
  // optional string desc = 2;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 2;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  
  // @@protoc_insertion_point(class_scope:Chat.LoginResult)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 user_id_;
  ::std::string* desc_;
  static const ::std::string _default_desc_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static LoginResult* default_instance_;
};
// -------------------------------------------------------------------

class UserConfig : public ::google::protobuf::Message {
 public:
  UserConfig();
  virtual ~UserConfig();
  
  UserConfig(const UserConfig& from);
  
  inline UserConfig& operator=(const UserConfig& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserConfig& default_instance();
  
  void Swap(UserConfig* other);
  
  // implements Message ----------------------------------------------
  
  UserConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserConfig& from);
  void MergeFrom(const UserConfig& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 use_sound = 1;
  inline bool has_use_sound() const;
  inline void clear_use_sound();
  static const int kUseSoundFieldNumber = 1;
  inline ::google::protobuf::int32 use_sound() const;
  inline void set_use_sound(::google::protobuf::int32 value);
  
  // optional int32 use_bubble = 2;
  inline bool has_use_bubble() const;
  inline void clear_use_bubble();
  static const int kUseBubbleFieldNumber = 2;
  inline ::google::protobuf::int32 use_bubble() const;
  inline void set_use_bubble(::google::protobuf::int32 value);
  
  // optional int32 font_color = 3;
  inline bool has_font_color() const;
  inline void clear_font_color();
  static const int kFontColorFieldNumber = 3;
  inline ::google::protobuf::int32 font_color() const;
  inline void set_font_color(::google::protobuf::int32 value);
  
  // optional string font_name = 4;
  inline bool has_font_name() const;
  inline void clear_font_name();
  static const int kFontNameFieldNumber = 4;
  inline const ::std::string& font_name() const;
  inline void set_font_name(const ::std::string& value);
  inline void set_font_name(const char* value);
  inline void set_font_name(const char* value, size_t size);
  inline ::std::string* mutable_font_name();
  
  // optional int32 font_style = 5;
  inline bool has_font_style() const;
  inline void clear_font_style();
  static const int kFontStyleFieldNumber = 5;
  inline ::google::protobuf::int32 font_style() const;
  inline void set_font_style(::google::protobuf::int32 value);
  
  // optional int32 font_size = 6;
  inline bool has_font_size() const;
  inline void clear_font_size();
  static const int kFontSizeFieldNumber = 6;
  inline ::google::protobuf::int32 font_size() const;
  inline void set_font_size(::google::protobuf::int32 value);
  
  // optional int32 run_start = 7;
  inline bool has_run_start() const;
  inline void clear_run_start();
  static const int kRunStartFieldNumber = 7;
  inline ::google::protobuf::int32 run_start() const;
  inline void set_run_start(::google::protobuf::int32 value);
  
  // optional int32 auto_login = 8;
  inline bool has_auto_login() const;
  inline void clear_auto_login();
  static const int kAutoLoginFieldNumber = 8;
  inline ::google::protobuf::int32 auto_login() const;
  inline void set_auto_login(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:Chat.UserConfig)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 use_sound_;
  ::google::protobuf::int32 use_bubble_;
  ::google::protobuf::int32 font_color_;
  ::std::string* font_name_;
  static const ::std::string _default_font_name_;
  ::google::protobuf::int32 font_style_;
  ::google::protobuf::int32 font_size_;
  ::google::protobuf::int32 run_start_;
  ::google::protobuf::int32 auto_login_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UserConfig* default_instance_;
};
// -------------------------------------------------------------------

class PostMsg : public ::google::protobuf::Message {
 public:
  PostMsg();
  virtual ~PostMsg();
  
  PostMsg(const PostMsg& from);
  
  inline PostMsg& operator=(const PostMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PostMsg& default_instance();
  
  void Swap(PostMsg* other);
  
  // implements Message ----------------------------------------------
  
  PostMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PostMsg& from);
  void MergeFrom(const PostMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 to_user_id = 1;
  inline bool has_to_user_id() const;
  inline void clear_to_user_id();
  static const int kToUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 to_user_id() const;
  inline void set_to_user_id(::google::protobuf::int32 value);
  
  // optional int32 from_user_id = 2;
  inline bool has_from_user_id() const;
  inline void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 from_user_id() const;
  inline void set_from_user_id(::google::protobuf::int32 value);
  
  // optional int32 msg_type = 3;
  inline bool has_msg_type() const;
  inline void clear_msg_type();
  static const int kMsgTypeFieldNumber = 3;
  inline ::google::protobuf::int32 msg_type() const;
  inline void set_msg_type(::google::protobuf::int32 value);
  
  // optional string text_msg = 4;
  inline bool has_text_msg() const;
  inline void clear_text_msg();
  static const int kTextMsgFieldNumber = 4;
  inline const ::std::string& text_msg() const;
  inline void set_text_msg(const ::std::string& value);
  inline void set_text_msg(const char* value);
  inline void set_text_msg(const char* value, size_t size);
  inline ::std::string* mutable_text_msg();
  
  // optional .Chat.CMD post_cmd = 5;
  inline bool has_post_cmd() const;
  inline void clear_post_cmd();
  static const int kPostCmdFieldNumber = 5;
  inline Chat::CMD post_cmd() const;
  inline void set_post_cmd(Chat::CMD value);
  
  // @@protoc_insertion_point(class_scope:Chat.PostMsg)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 to_user_id_;
  ::google::protobuf::int32 from_user_id_;
  ::google::protobuf::int32 msg_type_;
  ::std::string* text_msg_;
  static const ::std::string _default_text_msg_;
  int post_cmd_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static PostMsg* default_instance_;
};
// -------------------------------------------------------------------

class NetMsgReq : public ::google::protobuf::Message {
 public:
  NetMsgReq();
  virtual ~NetMsgReq();
  
  NetMsgReq(const NetMsgReq& from);
  
  inline NetMsgReq& operator=(const NetMsgReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NetMsgReq& default_instance();
  
  void Swap(NetMsgReq* other);
  
  // implements Message ----------------------------------------------
  
  NetMsgReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetMsgReq& from);
  void MergeFrom(const NetMsgReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Chat.CMD cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline Chat::CMD cmd() const;
  inline void set_cmd(Chat::CMD value);
  
  // required string user_ip = 2;
  inline bool has_user_ip() const;
  inline void clear_user_ip();
  static const int kUserIpFieldNumber = 2;
  inline const ::std::string& user_ip() const;
  inline void set_user_ip(const ::std::string& value);
  inline void set_user_ip(const char* value);
  inline void set_user_ip(const char* value, size_t size);
  inline ::std::string* mutable_user_ip();
  
  // optional .Chat.LoginInfo login_info = 4;
  inline bool has_login_info() const;
  inline void clear_login_info();
  static const int kLoginInfoFieldNumber = 4;
  inline const ::Chat::LoginInfo& login_info() const;
  inline ::Chat::LoginInfo* mutable_login_info();
  
  // optional int32 user_id = 5;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 5;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);
  
  // optional .Chat.UserConfig user_config = 6;
  inline bool has_user_config() const;
  inline void clear_user_config();
  static const int kUserConfigFieldNumber = 6;
  inline const ::Chat::UserConfig& user_config() const;
  inline ::Chat::UserConfig* mutable_user_config();
  
  // optional .Chat.PostMsg post_msg = 7;
  inline bool has_post_msg() const;
  inline void clear_post_msg();
  static const int kPostMsgFieldNumber = 7;
  inline const ::Chat::PostMsg& post_msg() const;
  inline ::Chat::PostMsg* mutable_post_msg();
  
  // optional int32 value = 8;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 8;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:Chat.NetMsgReq)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int cmd_;
  ::std::string* user_ip_;
  static const ::std::string _default_user_ip_;
  ::Chat::LoginInfo* login_info_;
  ::google::protobuf::int32 user_id_;
  ::Chat::UserConfig* user_config_;
  ::Chat::PostMsg* post_msg_;
  ::google::protobuf::int32 value_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static NetMsgReq* default_instance_;
};
// -------------------------------------------------------------------

class NetMsgRsp : public ::google::protobuf::Message {
 public:
  NetMsgRsp();
  virtual ~NetMsgRsp();
  
  NetMsgRsp(const NetMsgRsp& from);
  
  inline NetMsgRsp& operator=(const NetMsgRsp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NetMsgRsp& default_instance();
  
  void Swap(NetMsgRsp* other);
  
  // implements Message ----------------------------------------------
  
  NetMsgRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetMsgRsp& from);
  void MergeFrom(const NetMsgRsp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Chat.CMD cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline Chat::CMD cmd() const;
  inline void set_cmd(Chat::CMD value);
  
  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // optional .Chat.LoginResult login_result = 3;
  inline bool has_login_result() const;
  inline void clear_login_result();
  static const int kLoginResultFieldNumber = 3;
  inline const ::Chat::LoginResult& login_result() const;
  inline ::Chat::LoginResult* mutable_login_result();
  
  // optional .Chat.UserConfig user_config = 4;
  inline bool has_user_config() const;
  inline void clear_user_config();
  static const int kUserConfigFieldNumber = 4;
  inline const ::Chat::UserConfig& user_config() const;
  inline ::Chat::UserConfig* mutable_user_config();
  
  // @@protoc_insertion_point(class_scope:Chat.NetMsgRsp)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int cmd_;
  ::google::protobuf::int32 result_;
  ::Chat::LoginResult* login_result_;
  ::Chat::UserConfig* user_config_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static NetMsgRsp* default_instance_;
};
// -------------------------------------------------------------------

class TransMsg : public ::google::protobuf::Message {
 public:
  TransMsg();
  virtual ~TransMsg();
  
  TransMsg(const TransMsg& from);
  
  inline TransMsg& operator=(const TransMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransMsg& default_instance();
  
  void Swap(TransMsg* other);
  
  // implements Message ----------------------------------------------
  
  TransMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransMsg& from);
  void MergeFrom(const TransMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Chat.CMD cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline Chat::CMD cmd() const;
  inline void set_cmd(Chat::CMD value);
  
  // repeated .Chat.Region region = 2;
  inline int region_size() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 2;
  inline const ::Chat::Region& region(int index) const;
  inline ::Chat::Region* mutable_region(int index);
  inline ::Chat::Region* add_region();
  inline const ::google::protobuf::RepeatedPtrField< ::Chat::Region >&
      region() const;
  inline ::google::protobuf::RepeatedPtrField< ::Chat::Region >*
      mutable_region();
  
  // repeated .Chat.User user = 3;
  inline int user_size() const;
  inline void clear_user();
  static const int kUserFieldNumber = 3;
  inline const ::Chat::User& user(int index) const;
  inline ::Chat::User* mutable_user(int index);
  inline ::Chat::User* add_user();
  inline const ::google::protobuf::RepeatedPtrField< ::Chat::User >&
      user() const;
  inline ::google::protobuf::RepeatedPtrField< ::Chat::User >*
      mutable_user();
  
  // optional .Chat.PostMsg post_msg = 4;
  inline bool has_post_msg() const;
  inline void clear_post_msg();
  static const int kPostMsgFieldNumber = 4;
  inline const ::Chat::PostMsg& post_msg() const;
  inline ::Chat::PostMsg* mutable_post_msg();
  
  // required int32 result = 5;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 5;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // optional string desc = 6;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 6;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  
  // @@protoc_insertion_point(class_scope:Chat.TransMsg)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int cmd_;
  ::google::protobuf::RepeatedPtrField< ::Chat::Region > region_;
  ::google::protobuf::RepeatedPtrField< ::Chat::User > user_;
  ::Chat::PostMsg* post_msg_;
  ::google::protobuf::int32 result_;
  ::std::string* desc_;
  static const ::std::string _default_desc_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TransMsg* default_instance_;
};
// -------------------------------------------------------------------

class PRIVATE_MSG_RSP : public ::google::protobuf::Message {
 public:
  PRIVATE_MSG_RSP();
  virtual ~PRIVATE_MSG_RSP();
  
  PRIVATE_MSG_RSP(const PRIVATE_MSG_RSP& from);
  
  inline PRIVATE_MSG_RSP& operator=(const PRIVATE_MSG_RSP& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PRIVATE_MSG_RSP& default_instance();
  
  void Swap(PRIVATE_MSG_RSP* other);
  
  // implements Message ----------------------------------------------
  
  PRIVATE_MSG_RSP* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PRIVATE_MSG_RSP& from);
  void MergeFrom(const PRIVATE_MSG_RSP& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .Chat.CMD cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline Chat::CMD cmd() const;
  inline void set_cmd(Chat::CMD value);
  
  // optional int32 confirm = 2;
  inline bool has_confirm() const;
  inline void clear_confirm();
  static const int kConfirmFieldNumber = 2;
  inline ::google::protobuf::int32 confirm() const;
  inline void set_confirm(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:Chat.PRIVATE_MSG_RSP)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int cmd_;
  ::google::protobuf::int32 confirm_;
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static PRIVATE_MSG_RSP* default_instance_;
};
// ===================================================================


// ===================================================================

// Region

// optional int32 id = 1;
inline bool Region::has_id() const {
  return _has_bit(0);
}
inline void Region::clear_id() {
  id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Region::id() const {
  return id_;
}
inline void Region::set_id(::google::protobuf::int32 value) {
  _set_bit(0);
  id_ = value;
}

// optional string name = 2;
inline bool Region::has_name() const {
  return _has_bit(1);
}
inline void Region::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Region::name() const {
  return *name_;
}
inline void Region::set_name(const ::std::string& value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Region::set_name(const char* value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Region::set_name(const char* value, size_t size) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Region::mutable_name() {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional int32 parent_id = 4;
inline bool Region::has_parent_id() const {
  return _has_bit(2);
}
inline void Region::clear_parent_id() {
  parent_id_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 Region::parent_id() const {
  return parent_id_;
}
inline void Region::set_parent_id(::google::protobuf::int32 value) {
  _set_bit(2);
  parent_id_ = value;
}

// optional int32 ui_handle = 5;
inline bool Region::has_ui_handle() const {
  return _has_bit(3);
}
inline void Region::clear_ui_handle() {
  ui_handle_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 Region::ui_handle() const {
  return ui_handle_;
}
inline void Region::set_ui_handle(::google::protobuf::int32 value) {
  _set_bit(3);
  ui_handle_ = value;
}

// -------------------------------------------------------------------

// User

// optional string user_name = 1;
inline bool User::has_user_name() const {
  return _has_bit(0);
}
inline void User::clear_user_name() {
  if (user_name_ != &_default_user_name_) {
    user_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& User::user_name() const {
  return *user_name_;
}
inline void User::set_user_name(const ::std::string& value) {
  _set_bit(0);
  if (user_name_ == &_default_user_name_) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void User::set_user_name(const char* value) {
  _set_bit(0);
  if (user_name_ == &_default_user_name_) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void User::set_user_name(const char* value, size_t size) {
  _set_bit(0);
  if (user_name_ == &_default_user_name_) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_user_name() {
  _set_bit(0);
  if (user_name_ == &_default_user_name_) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}

// optional string user_pwd = 2;
inline bool User::has_user_pwd() const {
  return _has_bit(1);
}
inline void User::clear_user_pwd() {
  if (user_pwd_ != &_default_user_pwd_) {
    user_pwd_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& User::user_pwd() const {
  return *user_pwd_;
}
inline void User::set_user_pwd(const ::std::string& value) {
  _set_bit(1);
  if (user_pwd_ == &_default_user_pwd_) {
    user_pwd_ = new ::std::string;
  }
  user_pwd_->assign(value);
}
inline void User::set_user_pwd(const char* value) {
  _set_bit(1);
  if (user_pwd_ == &_default_user_pwd_) {
    user_pwd_ = new ::std::string;
  }
  user_pwd_->assign(value);
}
inline void User::set_user_pwd(const char* value, size_t size) {
  _set_bit(1);
  if (user_pwd_ == &_default_user_pwd_) {
    user_pwd_ = new ::std::string;
  }
  user_pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_user_pwd() {
  _set_bit(1);
  if (user_pwd_ == &_default_user_pwd_) {
    user_pwd_ = new ::std::string;
  }
  return user_pwd_;
}

// optional string user_ip = 3;
inline bool User::has_user_ip() const {
  return _has_bit(2);
}
inline void User::clear_user_ip() {
  if (user_ip_ != &_default_user_ip_) {
    user_ip_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& User::user_ip() const {
  return *user_ip_;
}
inline void User::set_user_ip(const ::std::string& value) {
  _set_bit(2);
  if (user_ip_ == &_default_user_ip_) {
    user_ip_ = new ::std::string;
  }
  user_ip_->assign(value);
}
inline void User::set_user_ip(const char* value) {
  _set_bit(2);
  if (user_ip_ == &_default_user_ip_) {
    user_ip_ = new ::std::string;
  }
  user_ip_->assign(value);
}
inline void User::set_user_ip(const char* value, size_t size) {
  _set_bit(2);
  if (user_ip_ == &_default_user_ip_) {
    user_ip_ = new ::std::string;
  }
  user_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_user_ip() {
  _set_bit(2);
  if (user_ip_ == &_default_user_ip_) {
    user_ip_ = new ::std::string;
  }
  return user_ip_;
}

// optional string display_name = 4;
inline bool User::has_display_name() const {
  return _has_bit(3);
}
inline void User::clear_display_name() {
  if (display_name_ != &_default_display_name_) {
    display_name_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& User::display_name() const {
  return *display_name_;
}
inline void User::set_display_name(const ::std::string& value) {
  _set_bit(3);
  if (display_name_ == &_default_display_name_) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
}
inline void User::set_display_name(const char* value) {
  _set_bit(3);
  if (display_name_ == &_default_display_name_) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
}
inline void User::set_display_name(const char* value, size_t size) {
  _set_bit(3);
  if (display_name_ == &_default_display_name_) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_display_name() {
  _set_bit(3);
  if (display_name_ == &_default_display_name_) {
    display_name_ = new ::std::string;
  }
  return display_name_;
}

// optional string user_phone = 5;
inline bool User::has_user_phone() const {
  return _has_bit(4);
}
inline void User::clear_user_phone() {
  if (user_phone_ != &_default_user_phone_) {
    user_phone_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& User::user_phone() const {
  return *user_phone_;
}
inline void User::set_user_phone(const ::std::string& value) {
  _set_bit(4);
  if (user_phone_ == &_default_user_phone_) {
    user_phone_ = new ::std::string;
  }
  user_phone_->assign(value);
}
inline void User::set_user_phone(const char* value) {
  _set_bit(4);
  if (user_phone_ == &_default_user_phone_) {
    user_phone_ = new ::std::string;
  }
  user_phone_->assign(value);
}
inline void User::set_user_phone(const char* value, size_t size) {
  _set_bit(4);
  if (user_phone_ == &_default_user_phone_) {
    user_phone_ = new ::std::string;
  }
  user_phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_user_phone() {
  _set_bit(4);
  if (user_phone_ == &_default_user_phone_) {
    user_phone_ = new ::std::string;
  }
  return user_phone_;
}

// optional int64 longin_time = 6;
inline bool User::has_longin_time() const {
  return _has_bit(5);
}
inline void User::clear_longin_time() {
  longin_time_ = GOOGLE_LONGLONG(0);
  _clear_bit(5);
}
inline ::google::protobuf::int64 User::longin_time() const {
  return longin_time_;
}
inline void User::set_longin_time(::google::protobuf::int64 value) {
  _set_bit(5);
  longin_time_ = value;
}

// optional int64 logout_time = 7;
inline bool User::has_logout_time() const {
  return _has_bit(6);
}
inline void User::clear_logout_time() {
  logout_time_ = GOOGLE_LONGLONG(0);
  _clear_bit(6);
}
inline ::google::protobuf::int64 User::logout_time() const {
  return logout_time_;
}
inline void User::set_logout_time(::google::protobuf::int64 value) {
  _set_bit(6);
  logout_time_ = value;
}

// optional int64 last_beat = 8;
inline bool User::has_last_beat() const {
  return _has_bit(7);
}
inline void User::clear_last_beat() {
  last_beat_ = GOOGLE_LONGLONG(0);
  _clear_bit(7);
}
inline ::google::protobuf::int64 User::last_beat() const {
  return last_beat_;
}
inline void User::set_last_beat(::google::protobuf::int64 value) {
  _set_bit(7);
  last_beat_ = value;
}

// optional int32 parent_id = 9;
inline bool User::has_parent_id() const {
  return _has_bit(8);
}
inline void User::clear_parent_id() {
  parent_id_ = 0;
  _clear_bit(8);
}
inline ::google::protobuf::int32 User::parent_id() const {
  return parent_id_;
}
inline void User::set_parent_id(::google::protobuf::int32 value) {
  _set_bit(8);
  parent_id_ = value;
}

// optional int32 user_id = 10;
inline bool User::has_user_id() const {
  return _has_bit(9);
}
inline void User::clear_user_id() {
  user_id_ = 0;
  _clear_bit(9);
}
inline ::google::protobuf::int32 User::user_id() const {
  return user_id_;
}
inline void User::set_user_id(::google::protobuf::int32 value) {
  _set_bit(9);
  user_id_ = value;
}

// optional int32 ui_handle = 11;
inline bool User::has_ui_handle() const {
  return _has_bit(10);
}
inline void User::clear_ui_handle() {
  ui_handle_ = 0;
  _clear_bit(10);
}
inline ::google::protobuf::int32 User::ui_handle() const {
  return ui_handle_;
}
inline void User::set_ui_handle(::google::protobuf::int32 value) {
  _set_bit(10);
  ui_handle_ = value;
}

// optional .Chat.UserConfig user_config = 12;
inline bool User::has_user_config() const {
  return _has_bit(11);
}
inline void User::clear_user_config() {
  if (user_config_ != NULL) user_config_->::Chat::UserConfig::Clear();
  _clear_bit(11);
}
inline const ::Chat::UserConfig& User::user_config() const {
  return user_config_ != NULL ? *user_config_ : *default_instance_->user_config_;
}
inline ::Chat::UserConfig* User::mutable_user_config() {
  _set_bit(11);
  if (user_config_ == NULL) user_config_ = new ::Chat::UserConfig;
  return user_config_;
}

// optional int32 udp_port = 13;
inline bool User::has_udp_port() const {
  return _has_bit(12);
}
inline void User::clear_udp_port() {
  udp_port_ = 0;
  _clear_bit(12);
}
inline ::google::protobuf::int32 User::udp_port() const {
  return udp_port_;
}
inline void User::set_udp_port(::google::protobuf::int32 value) {
  _set_bit(12);
  udp_port_ = value;
}

// optional int32 tcp_port = 14;
inline bool User::has_tcp_port() const {
  return _has_bit(13);
}
inline void User::clear_tcp_port() {
  tcp_port_ = 0;
  _clear_bit(13);
}
inline ::google::protobuf::int32 User::tcp_port() const {
  return tcp_port_;
}
inline void User::set_tcp_port(::google::protobuf::int32 value) {
  _set_bit(13);
  tcp_port_ = value;
}

// -------------------------------------------------------------------

// LoginInfo

// optional string user_name = 1;
inline bool LoginInfo::has_user_name() const {
  return _has_bit(0);
}
inline void LoginInfo::clear_user_name() {
  if (user_name_ != &_default_user_name_) {
    user_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& LoginInfo::user_name() const {
  return *user_name_;
}
inline void LoginInfo::set_user_name(const ::std::string& value) {
  _set_bit(0);
  if (user_name_ == &_default_user_name_) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void LoginInfo::set_user_name(const char* value) {
  _set_bit(0);
  if (user_name_ == &_default_user_name_) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void LoginInfo::set_user_name(const char* value, size_t size) {
  _set_bit(0);
  if (user_name_ == &_default_user_name_) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginInfo::mutable_user_name() {
  _set_bit(0);
  if (user_name_ == &_default_user_name_) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}

// optional string user_pwd = 2;
inline bool LoginInfo::has_user_pwd() const {
  return _has_bit(1);
}
inline void LoginInfo::clear_user_pwd() {
  if (user_pwd_ != &_default_user_pwd_) {
    user_pwd_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& LoginInfo::user_pwd() const {
  return *user_pwd_;
}
inline void LoginInfo::set_user_pwd(const ::std::string& value) {
  _set_bit(1);
  if (user_pwd_ == &_default_user_pwd_) {
    user_pwd_ = new ::std::string;
  }
  user_pwd_->assign(value);
}
inline void LoginInfo::set_user_pwd(const char* value) {
  _set_bit(1);
  if (user_pwd_ == &_default_user_pwd_) {
    user_pwd_ = new ::std::string;
  }
  user_pwd_->assign(value);
}
inline void LoginInfo::set_user_pwd(const char* value, size_t size) {
  _set_bit(1);
  if (user_pwd_ == &_default_user_pwd_) {
    user_pwd_ = new ::std::string;
  }
  user_pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginInfo::mutable_user_pwd() {
  _set_bit(1);
  if (user_pwd_ == &_default_user_pwd_) {
    user_pwd_ = new ::std::string;
  }
  return user_pwd_;
}

// optional string user_ip = 3;
inline bool LoginInfo::has_user_ip() const {
  return _has_bit(2);
}
inline void LoginInfo::clear_user_ip() {
  if (user_ip_ != &_default_user_ip_) {
    user_ip_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& LoginInfo::user_ip() const {
  return *user_ip_;
}
inline void LoginInfo::set_user_ip(const ::std::string& value) {
  _set_bit(2);
  if (user_ip_ == &_default_user_ip_) {
    user_ip_ = new ::std::string;
  }
  user_ip_->assign(value);
}
inline void LoginInfo::set_user_ip(const char* value) {
  _set_bit(2);
  if (user_ip_ == &_default_user_ip_) {
    user_ip_ = new ::std::string;
  }
  user_ip_->assign(value);
}
inline void LoginInfo::set_user_ip(const char* value, size_t size) {
  _set_bit(2);
  if (user_ip_ == &_default_user_ip_) {
    user_ip_ = new ::std::string;
  }
  user_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginInfo::mutable_user_ip() {
  _set_bit(2);
  if (user_ip_ == &_default_user_ip_) {
    user_ip_ = new ::std::string;
  }
  return user_ip_;
}

// -------------------------------------------------------------------

// LoginResult

// optional int32 user_id = 1;
inline bool LoginResult::has_user_id() const {
  return _has_bit(0);
}
inline void LoginResult::clear_user_id() {
  user_id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 LoginResult::user_id() const {
  return user_id_;
}
inline void LoginResult::set_user_id(::google::protobuf::int32 value) {
  _set_bit(0);
  user_id_ = value;
}

// optional string desc = 2;
inline bool LoginResult::has_desc() const {
  return _has_bit(1);
}
inline void LoginResult::clear_desc() {
  if (desc_ != &_default_desc_) {
    desc_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& LoginResult::desc() const {
  return *desc_;
}
inline void LoginResult::set_desc(const ::std::string& value) {
  _set_bit(1);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void LoginResult::set_desc(const char* value) {
  _set_bit(1);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void LoginResult::set_desc(const char* value, size_t size) {
  _set_bit(1);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResult::mutable_desc() {
  _set_bit(1);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  return desc_;
}

// -------------------------------------------------------------------

// UserConfig

// optional int32 use_sound = 1;
inline bool UserConfig::has_use_sound() const {
  return _has_bit(0);
}
inline void UserConfig::clear_use_sound() {
  use_sound_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 UserConfig::use_sound() const {
  return use_sound_;
}
inline void UserConfig::set_use_sound(::google::protobuf::int32 value) {
  _set_bit(0);
  use_sound_ = value;
}

// optional int32 use_bubble = 2;
inline bool UserConfig::has_use_bubble() const {
  return _has_bit(1);
}
inline void UserConfig::clear_use_bubble() {
  use_bubble_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 UserConfig::use_bubble() const {
  return use_bubble_;
}
inline void UserConfig::set_use_bubble(::google::protobuf::int32 value) {
  _set_bit(1);
  use_bubble_ = value;
}

// optional int32 font_color = 3;
inline bool UserConfig::has_font_color() const {
  return _has_bit(2);
}
inline void UserConfig::clear_font_color() {
  font_color_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 UserConfig::font_color() const {
  return font_color_;
}
inline void UserConfig::set_font_color(::google::protobuf::int32 value) {
  _set_bit(2);
  font_color_ = value;
}

// optional string font_name = 4;
inline bool UserConfig::has_font_name() const {
  return _has_bit(3);
}
inline void UserConfig::clear_font_name() {
  if (font_name_ != &_default_font_name_) {
    font_name_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& UserConfig::font_name() const {
  return *font_name_;
}
inline void UserConfig::set_font_name(const ::std::string& value) {
  _set_bit(3);
  if (font_name_ == &_default_font_name_) {
    font_name_ = new ::std::string;
  }
  font_name_->assign(value);
}
inline void UserConfig::set_font_name(const char* value) {
  _set_bit(3);
  if (font_name_ == &_default_font_name_) {
    font_name_ = new ::std::string;
  }
  font_name_->assign(value);
}
inline void UserConfig::set_font_name(const char* value, size_t size) {
  _set_bit(3);
  if (font_name_ == &_default_font_name_) {
    font_name_ = new ::std::string;
  }
  font_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserConfig::mutable_font_name() {
  _set_bit(3);
  if (font_name_ == &_default_font_name_) {
    font_name_ = new ::std::string;
  }
  return font_name_;
}

// optional int32 font_style = 5;
inline bool UserConfig::has_font_style() const {
  return _has_bit(4);
}
inline void UserConfig::clear_font_style() {
  font_style_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 UserConfig::font_style() const {
  return font_style_;
}
inline void UserConfig::set_font_style(::google::protobuf::int32 value) {
  _set_bit(4);
  font_style_ = value;
}

// optional int32 font_size = 6;
inline bool UserConfig::has_font_size() const {
  return _has_bit(5);
}
inline void UserConfig::clear_font_size() {
  font_size_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 UserConfig::font_size() const {
  return font_size_;
}
inline void UserConfig::set_font_size(::google::protobuf::int32 value) {
  _set_bit(5);
  font_size_ = value;
}

// optional int32 run_start = 7;
inline bool UserConfig::has_run_start() const {
  return _has_bit(6);
}
inline void UserConfig::clear_run_start() {
  run_start_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 UserConfig::run_start() const {
  return run_start_;
}
inline void UserConfig::set_run_start(::google::protobuf::int32 value) {
  _set_bit(6);
  run_start_ = value;
}

// optional int32 auto_login = 8;
inline bool UserConfig::has_auto_login() const {
  return _has_bit(7);
}
inline void UserConfig::clear_auto_login() {
  auto_login_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 UserConfig::auto_login() const {
  return auto_login_;
}
inline void UserConfig::set_auto_login(::google::protobuf::int32 value) {
  _set_bit(7);
  auto_login_ = value;
}

// -------------------------------------------------------------------

// PostMsg

// optional int32 to_user_id = 1;
inline bool PostMsg::has_to_user_id() const {
  return _has_bit(0);
}
inline void PostMsg::clear_to_user_id() {
  to_user_id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 PostMsg::to_user_id() const {
  return to_user_id_;
}
inline void PostMsg::set_to_user_id(::google::protobuf::int32 value) {
  _set_bit(0);
  to_user_id_ = value;
}

// optional int32 from_user_id = 2;
inline bool PostMsg::has_from_user_id() const {
  return _has_bit(1);
}
inline void PostMsg::clear_from_user_id() {
  from_user_id_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 PostMsg::from_user_id() const {
  return from_user_id_;
}
inline void PostMsg::set_from_user_id(::google::protobuf::int32 value) {
  _set_bit(1);
  from_user_id_ = value;
}

// optional int32 msg_type = 3;
inline bool PostMsg::has_msg_type() const {
  return _has_bit(2);
}
inline void PostMsg::clear_msg_type() {
  msg_type_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 PostMsg::msg_type() const {
  return msg_type_;
}
inline void PostMsg::set_msg_type(::google::protobuf::int32 value) {
  _set_bit(2);
  msg_type_ = value;
}

// optional string text_msg = 4;
inline bool PostMsg::has_text_msg() const {
  return _has_bit(3);
}
inline void PostMsg::clear_text_msg() {
  if (text_msg_ != &_default_text_msg_) {
    text_msg_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& PostMsg::text_msg() const {
  return *text_msg_;
}
inline void PostMsg::set_text_msg(const ::std::string& value) {
  _set_bit(3);
  if (text_msg_ == &_default_text_msg_) {
    text_msg_ = new ::std::string;
  }
  text_msg_->assign(value);
}
inline void PostMsg::set_text_msg(const char* value) {
  _set_bit(3);
  if (text_msg_ == &_default_text_msg_) {
    text_msg_ = new ::std::string;
  }
  text_msg_->assign(value);
}
inline void PostMsg::set_text_msg(const char* value, size_t size) {
  _set_bit(3);
  if (text_msg_ == &_default_text_msg_) {
    text_msg_ = new ::std::string;
  }
  text_msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PostMsg::mutable_text_msg() {
  _set_bit(3);
  if (text_msg_ == &_default_text_msg_) {
    text_msg_ = new ::std::string;
  }
  return text_msg_;
}

// optional .Chat.CMD post_cmd = 5;
inline bool PostMsg::has_post_cmd() const {
  return _has_bit(4);
}
inline void PostMsg::clear_post_cmd() {
  post_cmd_ = 10001;
  _clear_bit(4);
}
inline Chat::CMD PostMsg::post_cmd() const {
  return static_cast< Chat::CMD >(post_cmd_);
}
inline void PostMsg::set_post_cmd(Chat::CMD value) {
  GOOGLE_DCHECK(Chat::CMD_IsValid(value));
  _set_bit(4);
  post_cmd_ = value;
}

// -------------------------------------------------------------------

// NetMsgReq

// required .Chat.CMD cmd = 1;
inline bool NetMsgReq::has_cmd() const {
  return _has_bit(0);
}
inline void NetMsgReq::clear_cmd() {
  cmd_ = 10001;
  _clear_bit(0);
}
inline Chat::CMD NetMsgReq::cmd() const {
  return static_cast< Chat::CMD >(cmd_);
}
inline void NetMsgReq::set_cmd(Chat::CMD value) {
  GOOGLE_DCHECK(Chat::CMD_IsValid(value));
  _set_bit(0);
  cmd_ = value;
}

// required string user_ip = 2;
inline bool NetMsgReq::has_user_ip() const {
  return _has_bit(1);
}
inline void NetMsgReq::clear_user_ip() {
  if (user_ip_ != &_default_user_ip_) {
    user_ip_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& NetMsgReq::user_ip() const {
  return *user_ip_;
}
inline void NetMsgReq::set_user_ip(const ::std::string& value) {
  _set_bit(1);
  if (user_ip_ == &_default_user_ip_) {
    user_ip_ = new ::std::string;
  }
  user_ip_->assign(value);
}
inline void NetMsgReq::set_user_ip(const char* value) {
  _set_bit(1);
  if (user_ip_ == &_default_user_ip_) {
    user_ip_ = new ::std::string;
  }
  user_ip_->assign(value);
}
inline void NetMsgReq::set_user_ip(const char* value, size_t size) {
  _set_bit(1);
  if (user_ip_ == &_default_user_ip_) {
    user_ip_ = new ::std::string;
  }
  user_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NetMsgReq::mutable_user_ip() {
  _set_bit(1);
  if (user_ip_ == &_default_user_ip_) {
    user_ip_ = new ::std::string;
  }
  return user_ip_;
}

// optional .Chat.LoginInfo login_info = 4;
inline bool NetMsgReq::has_login_info() const {
  return _has_bit(2);
}
inline void NetMsgReq::clear_login_info() {
  if (login_info_ != NULL) login_info_->::Chat::LoginInfo::Clear();
  _clear_bit(2);
}
inline const ::Chat::LoginInfo& NetMsgReq::login_info() const {
  return login_info_ != NULL ? *login_info_ : *default_instance_->login_info_;
}
inline ::Chat::LoginInfo* NetMsgReq::mutable_login_info() {
  _set_bit(2);
  if (login_info_ == NULL) login_info_ = new ::Chat::LoginInfo;
  return login_info_;
}

// optional int32 user_id = 5;
inline bool NetMsgReq::has_user_id() const {
  return _has_bit(3);
}
inline void NetMsgReq::clear_user_id() {
  user_id_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 NetMsgReq::user_id() const {
  return user_id_;
}
inline void NetMsgReq::set_user_id(::google::protobuf::int32 value) {
  _set_bit(3);
  user_id_ = value;
}

// optional .Chat.UserConfig user_config = 6;
inline bool NetMsgReq::has_user_config() const {
  return _has_bit(4);
}
inline void NetMsgReq::clear_user_config() {
  if (user_config_ != NULL) user_config_->::Chat::UserConfig::Clear();
  _clear_bit(4);
}
inline const ::Chat::UserConfig& NetMsgReq::user_config() const {
  return user_config_ != NULL ? *user_config_ : *default_instance_->user_config_;
}
inline ::Chat::UserConfig* NetMsgReq::mutable_user_config() {
  _set_bit(4);
  if (user_config_ == NULL) user_config_ = new ::Chat::UserConfig;
  return user_config_;
}

// optional .Chat.PostMsg post_msg = 7;
inline bool NetMsgReq::has_post_msg() const {
  return _has_bit(5);
}
inline void NetMsgReq::clear_post_msg() {
  if (post_msg_ != NULL) post_msg_->::Chat::PostMsg::Clear();
  _clear_bit(5);
}
inline const ::Chat::PostMsg& NetMsgReq::post_msg() const {
  return post_msg_ != NULL ? *post_msg_ : *default_instance_->post_msg_;
}
inline ::Chat::PostMsg* NetMsgReq::mutable_post_msg() {
  _set_bit(5);
  if (post_msg_ == NULL) post_msg_ = new ::Chat::PostMsg;
  return post_msg_;
}

// optional int32 value = 8;
inline bool NetMsgReq::has_value() const {
  return _has_bit(6);
}
inline void NetMsgReq::clear_value() {
  value_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 NetMsgReq::value() const {
  return value_;
}
inline void NetMsgReq::set_value(::google::protobuf::int32 value) {
  _set_bit(6);
  value_ = value;
}

// -------------------------------------------------------------------

// NetMsgRsp

// required .Chat.CMD cmd = 1;
inline bool NetMsgRsp::has_cmd() const {
  return _has_bit(0);
}
inline void NetMsgRsp::clear_cmd() {
  cmd_ = 10001;
  _clear_bit(0);
}
inline Chat::CMD NetMsgRsp::cmd() const {
  return static_cast< Chat::CMD >(cmd_);
}
inline void NetMsgRsp::set_cmd(Chat::CMD value) {
  GOOGLE_DCHECK(Chat::CMD_IsValid(value));
  _set_bit(0);
  cmd_ = value;
}

// required int32 result = 2;
inline bool NetMsgRsp::has_result() const {
  return _has_bit(1);
}
inline void NetMsgRsp::clear_result() {
  result_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 NetMsgRsp::result() const {
  return result_;
}
inline void NetMsgRsp::set_result(::google::protobuf::int32 value) {
  _set_bit(1);
  result_ = value;
}

// optional .Chat.LoginResult login_result = 3;
inline bool NetMsgRsp::has_login_result() const {
  return _has_bit(2);
}
inline void NetMsgRsp::clear_login_result() {
  if (login_result_ != NULL) login_result_->::Chat::LoginResult::Clear();
  _clear_bit(2);
}
inline const ::Chat::LoginResult& NetMsgRsp::login_result() const {
  return login_result_ != NULL ? *login_result_ : *default_instance_->login_result_;
}
inline ::Chat::LoginResult* NetMsgRsp::mutable_login_result() {
  _set_bit(2);
  if (login_result_ == NULL) login_result_ = new ::Chat::LoginResult;
  return login_result_;
}

// optional .Chat.UserConfig user_config = 4;
inline bool NetMsgRsp::has_user_config() const {
  return _has_bit(3);
}
inline void NetMsgRsp::clear_user_config() {
  if (user_config_ != NULL) user_config_->::Chat::UserConfig::Clear();
  _clear_bit(3);
}
inline const ::Chat::UserConfig& NetMsgRsp::user_config() const {
  return user_config_ != NULL ? *user_config_ : *default_instance_->user_config_;
}
inline ::Chat::UserConfig* NetMsgRsp::mutable_user_config() {
  _set_bit(3);
  if (user_config_ == NULL) user_config_ = new ::Chat::UserConfig;
  return user_config_;
}

// -------------------------------------------------------------------

// TransMsg

// required .Chat.CMD cmd = 1;
inline bool TransMsg::has_cmd() const {
  return _has_bit(0);
}
inline void TransMsg::clear_cmd() {
  cmd_ = 10001;
  _clear_bit(0);
}
inline Chat::CMD TransMsg::cmd() const {
  return static_cast< Chat::CMD >(cmd_);
}
inline void TransMsg::set_cmd(Chat::CMD value) {
  GOOGLE_DCHECK(Chat::CMD_IsValid(value));
  _set_bit(0);
  cmd_ = value;
}

// repeated .Chat.Region region = 2;
inline int TransMsg::region_size() const {
  return region_.size();
}
inline void TransMsg::clear_region() {
  region_.Clear();
}
inline const ::Chat::Region& TransMsg::region(int index) const {
  return region_.Get(index);
}
inline ::Chat::Region* TransMsg::mutable_region(int index) {
  return region_.Mutable(index);
}
inline ::Chat::Region* TransMsg::add_region() {
  return region_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Chat::Region >&
TransMsg::region() const {
  return region_;
}
inline ::google::protobuf::RepeatedPtrField< ::Chat::Region >*
TransMsg::mutable_region() {
  return &region_;
}

// repeated .Chat.User user = 3;
inline int TransMsg::user_size() const {
  return user_.size();
}
inline void TransMsg::clear_user() {
  user_.Clear();
}
inline const ::Chat::User& TransMsg::user(int index) const {
  return user_.Get(index);
}
inline ::Chat::User* TransMsg::mutable_user(int index) {
  return user_.Mutable(index);
}
inline ::Chat::User* TransMsg::add_user() {
  return user_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Chat::User >&
TransMsg::user() const {
  return user_;
}
inline ::google::protobuf::RepeatedPtrField< ::Chat::User >*
TransMsg::mutable_user() {
  return &user_;
}

// optional .Chat.PostMsg post_msg = 4;
inline bool TransMsg::has_post_msg() const {
  return _has_bit(3);
}
inline void TransMsg::clear_post_msg() {
  if (post_msg_ != NULL) post_msg_->::Chat::PostMsg::Clear();
  _clear_bit(3);
}
inline const ::Chat::PostMsg& TransMsg::post_msg() const {
  return post_msg_ != NULL ? *post_msg_ : *default_instance_->post_msg_;
}
inline ::Chat::PostMsg* TransMsg::mutable_post_msg() {
  _set_bit(3);
  if (post_msg_ == NULL) post_msg_ = new ::Chat::PostMsg;
  return post_msg_;
}

// required int32 result = 5;
inline bool TransMsg::has_result() const {
  return _has_bit(4);
}
inline void TransMsg::clear_result() {
  result_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 TransMsg::result() const {
  return result_;
}
inline void TransMsg::set_result(::google::protobuf::int32 value) {
  _set_bit(4);
  result_ = value;
}

// optional string desc = 6;
inline bool TransMsg::has_desc() const {
  return _has_bit(5);
}
inline void TransMsg::clear_desc() {
  if (desc_ != &_default_desc_) {
    desc_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& TransMsg::desc() const {
  return *desc_;
}
inline void TransMsg::set_desc(const ::std::string& value) {
  _set_bit(5);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void TransMsg::set_desc(const char* value) {
  _set_bit(5);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void TransMsg::set_desc(const char* value, size_t size) {
  _set_bit(5);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransMsg::mutable_desc() {
  _set_bit(5);
  if (desc_ == &_default_desc_) {
    desc_ = new ::std::string;
  }
  return desc_;
}

// -------------------------------------------------------------------

// PRIVATE_MSG_RSP

// required .Chat.CMD cmd = 1;
inline bool PRIVATE_MSG_RSP::has_cmd() const {
  return _has_bit(0);
}
inline void PRIVATE_MSG_RSP::clear_cmd() {
  cmd_ = 10001;
  _clear_bit(0);
}
inline Chat::CMD PRIVATE_MSG_RSP::cmd() const {
  return static_cast< Chat::CMD >(cmd_);
}
inline void PRIVATE_MSG_RSP::set_cmd(Chat::CMD value) {
  GOOGLE_DCHECK(Chat::CMD_IsValid(value));
  _set_bit(0);
  cmd_ = value;
}

// optional int32 confirm = 2;
inline bool PRIVATE_MSG_RSP::has_confirm() const {
  return _has_bit(1);
}
inline void PRIVATE_MSG_RSP::clear_confirm() {
  confirm_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 PRIVATE_MSG_RSP::confirm() const {
  return confirm_;
}
inline void PRIVATE_MSG_RSP::set_confirm(::google::protobuf::int32 value) {
  _set_bit(1);
  confirm_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Chat

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< Chat::CMD>() {
  return Chat::CMD_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_2eproto__INCLUDED
